<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>UDS: Unlearning Depth Score - Benchmark Results</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
<style>
* { box-sizing: border-box; }
body {
  font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  margin: 0; padding: 20px 24px;
  font-size: 15px; color: #1a1a1a;
  background: #f8f9fa;
  line-height: 1.5;
}
h1 { font-size: 1.8rem; font-weight: 700; margin: 0 0 8px 0; color: #111; }
h2 { font-size: 1.3rem; font-weight: 600; margin: 24px 0 12px 0; color: #222; border-bottom: 2px solid #e0e0e0; padding-bottom: 6px; }
h3 { font-size: 1.1rem; font-weight: 600; margin: 16px 0 8px 0; color: #333; }

.container { max-width: 1400px; margin: 0 auto; }
.card {
  background: #fff;
  border: 1px solid #e0e0e0;
  border-radius: 8px;
  padding: 16px 20px;
  margin-bottom: 16px;
  box-shadow: 0 1px 3px rgba(0,0,0,0.04);
}
.card.uds-intro {
  border-left: 4px solid #ffc107;
  background: #fffef5;
}
.formula-box {
  background: #f6f8fa;
  border-left: 3px solid #0366d6;
  padding: 12px 16px;
  font-size: 14px;
  margin: 12px 0;
  border-radius: 0 6px 6px 0;
}
.formula-box code { background: #e8ecf0; padding: 2px 6px; border-radius: 3px; font-size: 13px; }
.formula-box .sub-formula { margin-left: 20px; color: #555; font-size: 13px; }
.higher-better { color: #2e7d32; font-weight: 600; }
.uds-highlight { background: #fff8e1; padding: 2px 6px; border-radius: 3px; font-weight: 600; }

/* Tables */
.table-wrap { overflow-x: auto; margin: 12px 0; }
table.styled {
  border-collapse: collapse;
  width: 100%;
  font-size: 14px;
  background: #fff;
}
table.styled th, table.styled td {
  border: 1px solid #e0e0e0;
  padding: 8px 12px;
  text-align: left;
}
table.styled th {
  background: #f6f8fa;
  font-weight: 600;
  cursor: pointer;
  user-select: none;
  white-space: nowrap;
}
table.styled th:hover { background: #eef1f4; }
table.styled th.sort-asc::after { content: " ▲"; font-size: 10px; }
table.styled th.sort-desc::after { content: " ▼"; font-size: 10px; }
table.styled tbody tr:hover { background: #f8f9fa; }
table.styled td { font-variant-numeric: tabular-nums; }
table.styled td.num { text-align: right; }
table.styled th.num { text-align: right; }

/* Meta-eval specific */
#meta_eval .uds-row { background: #fffde7 !important; }
#meta_eval .uds-row:hover { background: #fff9c4 !important; }
#meta_eval th:nth-child(n+2), #meta_eval td:nth-child(n+2) { min-width: 110px; }

/* Method table specific */
#method_table .ref-row { background: #e3f2fd !important; }
#method_table .ref-row:hover { background: #bbdefb !important; }
#method_table th:nth-child(n+2):nth-child(-n+6), #method_table td:nth-child(n+2):nth-child(-n+6) { min-width: 95px; }
#method_table th:nth-child(7), #method_table td:nth-child(7) { text-align: center; width: 40px; }
.expand-cell { padding: 4px !important; }
.toggle-btn { font-size: 12px; padding: 2px 8px; min-width: 28px; }
.details-row { display: none; background: #fafafa !important; }
.details-row td { padding: 12px 16px; }
.details-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 16px; }
.detail-card {
  background: #fff;
  border: 1px solid #e0e0e0;
  border-radius: 6px;
  padding: 12px;
}
.detail-card h4 {
  margin: 0 0 10px 0;
  font-size: 13px;
  font-weight: 600;
  color: #333;
  border-bottom: 1px solid #eee;
  padding-bottom: 6px;
}
.detail-item { display: flex; justify-content: space-between; padding: 2px 0; }
.detail-item .label { color: #666; }
.detail-item .value { font-weight: 500; font-variant-numeric: tabular-nums; }
.detail-item.summary { border-top: 1px solid #eee; margin-top: 6px; padding-top: 6px; }
.detail-sub { margin-top: 8px; font-size: 12px; color: #666; }

/* Controls */
.controls {
  background: #fff;
  border: 1px solid #e0e0e0;
  border-radius: 8px;
  padding: 16px;
  margin-bottom: 16px;
}
.control-row { display: flex; align-items: flex-start; gap: 12px; margin-bottom: 12px; }
.control-row:last-child { margin-bottom: 0; }
.control-label { min-width: 90px; font-weight: 600; color: #333; padding-top: 4px; }
.control-content { display: flex; flex-wrap: wrap; gap: 8px; align-items: center; }
.method-grid { display: flex; flex-wrap: wrap; gap: 6px 16px; }
.checkbox-label {
  display: flex; align-items: center; gap: 4px;
  font-size: 13px; cursor: pointer;
}
.checkbox-label input { margin: 0; }
.checkbox-label .count { color: #888; font-size: 12px; }
select, button.btn {
  padding: 6px 12px;
  font-size: 13px;
  border: 1px solid #d0d0d0;
  border-radius: 4px;
  background: #fff;
  cursor: pointer;
}
select:focus, button.btn:focus { outline: 2px solid #0366d6; outline-offset: 1px; }
button.btn { background: #f6f8fa; }
button.btn:hover { background: #eef1f4; }
button.toggle-btn {
  background: none;
  border: none;
  color: #0366d6;
  cursor: pointer;
  font-size: 14px;
  padding: 4px 8px;
}
button.toggle-btn:hover { text-decoration: underline; }

/* Hints */
.hint { color: #666; font-size: 12px; margin-bottom: 8px; }

/* Loading */
.loading { text-align: center; padding: 40px; color: #666; }
</style>
</head>
<body>
<div class="container">
  <h1>UDS: Unlearning Depth Score</h1>
  <p style="color:#666; margin-top:0;">Benchmark results on TOFU dataset using Llama-3.2-1B-Instruct (Open-Unlearning framework)</p>

  <!-- UDS Introduction -->
  <div class="card uds-intro">
    <h3 style="margin-top:0; color:#b8860b;">UDS: Unlearning Depth Score</h3>
    <p style="margin:0 0 10px 0;">
      <strong>UDS (Unlearning Depth Score)</strong> is a metric that quantifies the <em>mechanistic depth</em> of unlearning by measuring how much target knowledge is recoverable through activation patching.
    </p>
    <p style="margin:0 0 10px 0;">
      <strong>Method:</strong> We patch hidden states from the unlearned model into a full (knowledge-present) model layer by layer, and measure how much the patching recovers the original knowledge. If knowledge is truly erased, patching should not help recovery.
    </p>
    <div class="formula-box" style="margin-bottom:0;">
      <code>UDS</code> = weighted average of per-layer erasure ratios, where higher = deeper/better unlearning.<br>
      <span class="sub-formula">UDS ranges from 0 (no unlearning, knowledge fully recoverable) to 1 (complete unlearning, no recovery possible).</span>
    </div>
  </div>

  <!-- Meta-evaluation Section -->
  <h2>Meta-evaluation</h2>
  <div class="card">
    <p style="margin:0 0 12px 0;">
      This section evaluates <strong>13 metrics</strong> (+ 4 normalized MIA variants) across 5 categories to measure <strong>how reliable each unlearning metric is</strong>, using the Open-Unlearning benchmark framework.
    </p>
    <p style="margin:0 0 12px 0;">
      <strong>Faithfulness</strong>: How well each metric separates knowledge-present (P, 30 models) vs knowledge-absent (N, 30 models), measured by AUC-ROC.<br>
      <strong>Robustness</strong>: Stability of each metric under post-hoc perturbations (4-bit quantization, 1-epoch relearning).
    </p>

    <div class="formula-box" style="margin:0 0 14px 0;">
      <div><strong>Metric Categories (13 + 4 normalized)</strong></div>

      <div style="margin-top:10px;">
        <strong>Memorization</strong> (5) &mdash; Does the model still retain memorized target knowledge?<br>
        <code>ES</code> (Extraction Strength) &mdash; fraction of answer suffix extractable via greedy decoding. <span class="sub-formula">1 &minus; k/T, k = earliest match position (Carlini et al., 2021)</span><br>
        <code>EM</code> (Exact Memorization) &mdash; token-level position match ratio. <span class="sub-formula">&Sigma; &Iopf;(pred<sub>t</sub> = label<sub>t</sub>) / T &ensp;(continuous [0,1]; Tirumala et al., 2022)</span><br>
        <code>Prob</code> &mdash; geometric mean of per-token probabilities. <span class="sub-formula">exp(&minus;(1/T) &Sigma; CE<sub>t</sub>)</span><br>
        <code>ParaProb</code> &mdash; geometric mean of Prob across paraphrased versions of the target.<br>
        <code>Truth Ratio</code> &mdash; normalized correct vs. incorrect probability. <span class="sub-formula">p<sub>c</sub> / (p<sub>c</sub> + p<sub>w</sub> + &epsilon;), &ensp;p = exp(&minus;avg loss)</span>
      </div>

      <div style="margin-top:10px;">
        <strong>Generation</strong> (3) &mdash; Can the model reproduce target knowledge in free-form text?<br>
        ROUGE-L recall between model generation and ground-truth answer under different prompting strategies.<br>
        <code>ROUGE</code> standard prompt &middot;
        <code>Para. ROUGE</code> paraphrased prompt &middot;
        <code>Jailbreak ROUGE</code> adversarial prompt (prefixed with &ldquo;Sure, here is the answer:&rdquo;)
      </div>

      <div style="margin-top:10px;">
        <strong>MIA</strong> (4) &mdash; Membership Inference Attack (raw AUC).<br>
        Per-sample score for member vs. non-member classification; reported as AUC-ROC.<br>
        <code>MIA-LOSS</code> &mdash; average cross-entropy. <span class="sub-formula">(1/T) &Sigma; CE<sub>t</sub></span><br>
        <code>MIA-ZLib</code> &mdash; loss normalized by compression length. <span class="sub-formula">avg_loss / len(zlib(text))</span><br>
        <code>MIA-Min-K</code> &mdash; mean of the bottom-k% log-probs. <span class="sub-formula">&minus;mean(sorted(log p<sub>t</sub>)[:&lceil;kT&rceil;]), k=0.4</span><br>
        <code>MIA-Min-K++</code> &mdash; standardized Min-K. <span class="sub-formula">z<sub>t</sub> = (log p<sub>t</sub> &minus; &mu;<sub>t</sub>) / &sigma;<sub>t</sub>, then min-k selection</span>
      </div>

      <div style="margin-top:10px;">
        <strong>Normalized MIA</strong> (4, denoted s<sub>*</sub>) &mdash; MIA rescaled to [0, 1] using retain/full as anchors.<br>
        <span class="sub-formula">clip(1 &minus; |AUC<sub>model</sub> &minus; AUC<sub>retain</sub>| / |AUC<sub>full</sub> &minus; AUC<sub>retain</sub>|, 0, 1)</span><br>
        <span class="sub-formula">1.0 = indistinguishable from retain (knowledge erased) &middot; 0.0 = same as full (knowledge intact)</span><br>
        s<sub>LOSS</sub> &middot; s<sub>ZLib</sub> &middot; s<sub>Min-K</sub> &middot; s<sub>Min-K++</sub>
      </div>

      <div style="margin-top:10px;">
        <strong>UDS (Ours)</strong> (1) &mdash; Output suppression &ne; knowledge erasure. UDS measures whether knowledge remains recoverable from internal representations via activation patching.<br>
        <span class="sub-formula">&Delta;<sup>S1</sup><sub>l</sub> = logprob drop patching retain &rarr; full (baseline gap) &ensp;&middot;&ensp; &Delta;<sup>S2</sup><sub>l</sub> = logprob drop patching unlearned &rarr; full (test gap)</span><br>
        <span class="sub-formula">FT = { l : &Delta;<sup>S1</sup><sub>l</sub> &gt; &tau; } (&tau;=0.05) &ensp;&middot;&ensp; UDS<sub>i</sub> = &Sigma;<sub>l&isin;FT</sub> [&Delta;<sup>S1</sup><sub>l</sub> &middot; clip(&Delta;<sup>S2</sup><sub>l</sub>/&Delta;<sup>S1</sup><sub>l</sub>, 0, 1)] / &Sigma;<sub>l&isin;FT</sub> &Delta;<sup>S1</sup><sub>l</sub></span><br>
        <span class="sub-formula">UDS = (1/N) &Sigma;<sub>i</sub> UDS<sub>i</sub> (N=367) &ensp;&middot;&ensp; 1.0 = complete erasure &middot; 0.0 = knowledge intact</span>
      </div>
    </div>

    <p id="meta_eval_summary" style="margin:0 0 12px 0; padding:8px 12px; background:#fffde7; border-radius:4px;">
      <strong>Meta-evaluation summary:</strong> loading...
    </p>
    <div class="formula-box">
      <div><strong>Formulas:</strong></div>
      <div style="margin-top:6px;">
        <code>Faithfulness</code> = AUC-ROC over P/N pools (30 knowledge-present vs 30 knowledge-absent models)
      </div>
      <div style="margin-top:8px;">
        <code>Robustness</code> = HM(Quantization, Relearning)<br>
        <span class="sub-formula"><code>Quantization (Q)</code> = min(m<sub>before</sub> / m<sub>after</sub>, 1) &mdash; Q &asymp; 1 means metric stays stable after 4-bit quantization</span><br>
        <span class="sub-formula"><code>Relearning (R)</code> = min(&Delta;<sub>retain</sub> / &Delta;<sub>unlearn</sub>, 1) &mdash; R &asymp; 1 means metric doesn't recover after 1-epoch fine-tuning</span><br>
        <span class="sub-formula">Direction: raw values for standard metrics; m = 1 &minus; value for UDS and s<sub>*</sub> (inverted direction).</span><br>
        <span class="sub-formula">Filtering: utility &ge; 0.8 + per-metric faithfulness-threshold (150 models &rarr; per-metric filtered subset).</span>
      </div>
      <div style="margin-top:8px;">
        <code>Overall</code> = HM(Faithfulness, Robustness)
      </div>
    </div>
  </div>

  <div class="hint">Per column: <strong>best</strong> value is bold, <u>second-best</u> is underlined.</div>
  <div class="table-wrap">
    <table class="styled" id="meta_eval">
      <thead>
        <tr>
          <th rowspan="2">Metric</th>
          <th rowspan="2" class="sortable num" data-col="overall">Overall ↑</th>
          <th rowspan="2" class="sortable num" data-col="faith">Faithfulness ↑</th>
          <th colspan="3" style="text-align:center;">Robustness</th>
        </tr>
        <tr>
          <th class="sortable num" data-col="rob">Agg. ↑</th>
          <th class="sortable num" data-col="quant">Quantization ↑</th>
          <th class="sortable num" data-col="relearn">Relearning ↑</th>
        </tr>
      </thead>
      <tbody id="meta_eval_body">
        <tr><td colspan="6" class="loading">Loading...</td></tr>
      </tbody>
    </table>
  </div>

  <!-- Method-level Section -->
  <h2>Method-level Results</h2>
  <div class="card">
    <p style="margin:0 0 12px 0;">
      This section evaluates <strong><span id="model_total_count">152</span> models</strong> (8 methods &times; varying hyperparameters &times; 2 epochs + full + retain) across three axes.
      All unlearned model checkpoints are from the <a href="https://github.com/locuslab/open-unlearning" target="_blank" style="color:#0366d6;">Open-Unlearning</a> framework.
    </p>
    <p style="margin:0 0 12px 0;">
      <strong>Memorization</strong>: How much target knowledge was forgotten. <span class="higher-better">(↑ higher = more forgotten)</span><br>
      <strong>Privacy</strong>: How well sensitive information from the forget set is protected from being extracted (assessed via MIAs and UDS). <span class="higher-better">(↑ higher = better protected)</span><br>
      <strong>Utility</strong>: How well the model retains general capabilities on non-target knowledge. <span class="higher-better">(↑ higher = better retention)</span><br>
      <strong>Overall</strong>: Harmonic mean of all three axes. <span class="higher-better">(↑ higher = better)</span>
    </p>
    <p style="margin:0 0 12px 0; padding:8px 12px; background:#fffde7; border-radius:4px;">
      <span class="uds-highlight">UDS</span> is incorporated into the Privacy axis as <code>Privacy = HM(MIA, UDS)</code>, capturing both statistical (MIA) and mechanistic (UDS) aspects.
    </p>
    <div class="formula-box">
      <div><strong>Formulas:</strong></div>
      <div style="margin-top:8px;">
        <strong>Memorization:</strong><br>
        <code>Mem.</code> = HM(1-ES, 1-EM, 1-ParaProb, 1-TruthRatio)<br>
        <span class="sub-formula">ES=Extraction Strength, EM=Exact Memorization, ParaProb=Paraphrase Probability, TruthRatio=Truth Ratio</span>
      </div>
      <div style="margin-top:10px;">
        <strong>Privacy:</strong><br>
        <code>MIA</code> = HM(s<sub>LOSS</sub>, s<sub>ZLib</sub>, s<sub>Min-K</sub>, s<sub>Min-K++</sub>)<br>
        <span class="sub-formula">s<sub>*</sub> = normalized MIA scores (see Metric Categories above)</span><br>
        <code>Privacy</code> = HM(MIA, <span class="uds-highlight">UDS</span>)
      </div>
      <div style="margin-top:10px;">
        <strong>Utility:</strong><br>
        <code>ModelUtility (MU)</code> = HM(retain_Prob, retain_ROUGE, retain_TruthRatio, ra_Prob, ra_ROUGE, ra_TruthRatio, wf_Prob, wf_ROUGE, wf_TruthRatio)<br>
        <span class="sub-formula">retain=Retain set, ra=Real Authors, wf=World Facts</span><br>
        <code>Fluency</code> = generation fluency score<br>
        <code>Utility</code> = HM(MU, Fluency), then normalized: Utility<sub>rel</sub> = Utility / Utility<sub>full(epoch)</sub>
      </div>
      <div style="margin-top:10px;">
        <strong>Overall:</strong><br>
        <code>Overall</code> = HM(Mem., Privacy, Utility<sub>rel</sub>)
      </div>
    </div>
  </div>

  <!-- Controls -->
  <div class="controls">
    <div class="control-row">
      <span class="control-label">View</span>
      <div class="control-content">
        <select id="viewMode">
          <option value="all">All models</option>
          <option value="best">Top-1 per method</option>
        </select>
        <select id="rankMetric" style="margin-left:8px; display:none;">
          <option value="overall">by Overall</option>
          <option value="mem">by Memorization</option>
          <option value="privacy">by Privacy</option>
          <option value="utility_rel">by Utility</option>
          <option value="uds">by UDS</option>
        </select>
      </div>
    </div>
    <div class="control-row">
      <span class="control-label">Epoch</span>
      <div class="control-content">
        <label class="checkbox-label"><input type="checkbox" class="epoch-filter" value="ep5" checked> 5</label>
        <label class="checkbox-label"><input type="checkbox" class="epoch-filter" value="ep10" checked> 10</label>
      </div>
    </div>
    <div class="control-row">
      <span class="control-label">Methods</span>
      <div class="control-content" style="flex-direction:column; align-items:flex-start; gap:8px;">
        <div class="method-grid" id="method_filters"></div>
        <div>
          <button class="btn" id="checkAll">Check All</button>
          <button class="btn" id="uncheckAll">Uncheck All</button>
        </div>
      </div>
    </div>
  </div>

  <div class="hint" id="model_count">Total: loading...</div>
  <div class="table-wrap">
    <table class="styled" id="method_table">
      <thead>
        <tr>
          <th class="sortable" data-col="model">Model</th>
          <th class="sortable num" data-col="overall">Overall ↑</th>
          <th class="sortable num" data-col="mem" style="white-space:nowrap;">Mem. ↑</th>
          <th class="sortable num" data-col="privacy">Privacy ↑</th>
          <th class="sortable num" data-col="utility_rel">Utility ↑</th>
          <th class="sortable num" data-col="uds" style="color:#888;" title="Already included in Privacy axis">UDS ↑</th>
          <th></th>
        </tr>
      </thead>
      <tbody id="method_body">
        <tr><td colspan="7" class="loading">Loading...</td></tr>
      </tbody>
    </table>
  </div>
</div>

<script>
// Data storage
let metaData = null;
let methodData = null;
let currentSort = { col: null, asc: true };
let metaSort = { col: null, asc: true };

// Method name display mapping
const methodDisplayNames = {
  'graddiff': 'GradDiff',
  'idknll': 'IdkNLL',
  'idkdpo': 'IdkDPO',
  'npo': 'NPO',
  'altpo': 'AltPO',
  'undial': 'UNDIAL',
  'simnpo': 'SimNPO',
  'rmu': 'RMU'
};

function displayMethod(m) {
  return methodDisplayNames[m.toLowerCase()] || m;
}

// Utility functions
function fmt(v) {
  if (v === null || v === undefined || (typeof v === 'number' && isNaN(v))) return 'N/A';
  return v.toFixed(3);
}

function top2(values) {
  const nums = [...new Set(values.filter(v => v !== null && !isNaN(v)))].sort((a,b) => b-a);
  return [nums[0] || null, nums[1] || null];
}

function styleRank(v, best, second) {
  if (v === null || v === undefined || isNaN(v)) return 'N/A';
  const s = fmt(v);
  if (best !== null && Math.abs(v - best) < 1e-9) return `<strong>${s}</strong>`;
  if (second !== null && Math.abs(v - second) < 1e-9) return `<u>${s}</u>`;
  return s;
}

// Load meta-eval data
async function loadMetaEval() {
  try {
    const resp = await fetch('data/meta_eval.json');
    metaData = await resp.json();
    renderMetaEval();
    setupMetaSorting();
  } catch (e) {
    document.getElementById('meta_eval_body').innerHTML = '<tr><td colspan="6">Error loading data</td></tr>';
  }
}

function setupMetaSorting() {
  document.querySelectorAll('#meta_eval th.sortable').forEach(th => {
    th.addEventListener('click', () => {
      const col = th.dataset.col;
      if (metaSort.col === col) {
        if (metaSort.asc) {
          // Third click: reset to default (no sort)
          metaSort.col = null;
          metaSort.asc = true;
        } else {
          metaSort.asc = true;
        }
      } else {
        metaSort.col = col;
        metaSort.asc = false; // Default descending (higher is better)
      }
      document.querySelectorAll('#meta_eval th.sortable').forEach(h => {
        h.classList.remove('sort-asc', 'sort-desc');
      });
      if (metaSort.col) th.classList.add(metaSort.asc ? 'sort-asc' : 'sort-desc');
      renderMetaEval();
    });
  });
}

function renderMetaEval() {
  const body = document.getElementById('meta_eval_body');
  const metrics = metaData.metrics;
  const faith = metaData.faithfulness;
  const robust = metaData.robustness || {};

  // Collect values for ranking
  const overalls = [], faiths = [], robs = [], quants = [], relearns = [];
  const rows = metrics.map(m => {
    const f = faith[m.key]?.auc_roc || null;
    const r = robust[m.key]?.agg ?? null;
    const q = robust[m.key]?.quantization ?? null;
    const rl = robust[m.key]?.relearning ?? null;
    const o = (f !== null && r !== null) ? 2 / (1/f + 1/r) : null;
    overalls.push(o); faiths.push(f); robs.push(r); quants.push(q); relearns.push(rl);
    return { ...m, faith: f, rob: r, quant: q, relearn: rl, overall: o };
  });

  const [bestO, secO] = top2(overalls);
  const [bestF, secF] = top2(faiths);
  const [bestR, secR] = top2(robs);
  const [bestQ, secQ] = top2(quants);
  const [bestL, secL] = top2(relearns);

  // Sort if needed
  if (metaSort.col) {
    rows.sort((a, b) => {
      let av = a[metaSort.col], bv = b[metaSort.col];
      if (av === null || isNaN(av)) av = -Infinity;
      if (bv === null || isNaN(bv)) bv = -Infinity;
      return metaSort.asc ? av - bv : bv - av;
    });
  }

  let html = '';
  rows.forEach((r, i) => {
    const classes = [];
    if (r.key === 'uds') classes.push('uds-row');

    const isUds = r.key === 'uds';
    let label = r.label.replace(/^s_(.+)$/, 's<sub>$1</sub>');
    if (isUds) label = `<strong>${label}</strong>`;

    html += `<tr class="${classes.join(' ')}">
      <td>${label}</td>
      <td class="num">${styleRank(r.overall, bestO, secO)}</td>
      <td class="num">${styleRank(r.faith, bestF, secF)}</td>
      <td class="num">${styleRank(r.rob, bestR, secR)}</td>
      <td class="num">${styleRank(r.quant, bestQ, secQ)}</td>
      <td class="num">${styleRank(r.relearn, bestL, secL)}</td>
    </tr>`;
  });
  body.innerHTML = html;

  // Dynamic summary (avoid stale hardcoded claims)
  const overallPairs = rows
    .filter(r => r.overall !== null && !isNaN(r.overall))
    .sort((a, b) => b.overall - a.overall);
  const summaryEl = document.getElementById('meta_eval_summary');
  if (overallPairs.length > 0) {
    const fmtLabel = s => s.replace(/^s_(.+)$/, 's<sub>$1</sub>');
    const top = overallPairs[0];

    // Best per axis
    const faithSorted = [...overallPairs].sort((a, b) => (b.faith || 0) - (a.faith || 0));
    const robSorted = [...overallPairs].sort((a, b) => (b.rob || 0) - (a.rob || 0));
    const topWinsBoth = top.key === faithSorted[0].key && top.key === robSorted[0].key;

    // Pattern analysis: Q vs R
    const validQ = rows.filter(r => r.quant !== null && !isNaN(r.quant));
    const validR = rows.filter(r => r.relearn !== null && !isNaN(r.relearn));
    const avgQ = validQ.reduce((s, r) => s + r.quant, 0) / validQ.length;
    const avgR = validR.reduce((s, r) => s + r.relearn, 0) / validR.length;
    const lowR = validR.filter(r => r.relearn < 0.5).length;

    // Faithfulness-robustness disconnect: high faith but low robustness
    const highFaithLowRob = overallPairs.filter(r => r.faith >= 0.9 && r.rob < 0.5);

    let msg = `<strong>Meta-evaluation summary:</strong><br>`;

    // 1) Winner
    msg += `<span class="uds-highlight">${fmtLabel(top.label)}</span> achieves the highest Overall score (<strong>${fmt(top.overall)}</strong>)`;
    if (topWinsBoth) {
      msg += `, ranking <strong>#1 in both Faithfulness (${fmt(top.faith)}) and Robustness (${fmt(top.rob)})</strong>.`;
    } else {
      msg += ` &mdash; Faithfulness ${fmt(top.faith)}, Robustness ${fmt(top.rob)}.`;
    }
    if (overallPairs.length > 1) {
      const sec = overallPairs[1];
      msg += ` Second: ${fmtLabel(sec.label)} (${fmt(sec.overall)}).`;
    }

    // 2) Key pattern
    msg += `<br>Relearning robustness is the main bottleneck: avg Q=${avgQ.toFixed(2)} vs avg R=${avgR.toFixed(2)} (<strong>${lowR}/${validR.length}</strong> metrics have R&lt;0.5).`;

    // 3) Trade-off example
    if (highFaithLowRob.length > 0) {
      const ex = highFaithLowRob[0];
      msg += `<br>e.g., ${fmtLabel(ex.label)} has high faithfulness (${fmt(ex.faith)}) but R=${fmt(ex.relearn)} &mdash; easily reversed by 1-epoch fine-tuning.`;
    }

    // 4) Top metric advantage
    if (top.quant !== null && top.relearn !== null) {
      msg += `<br>${fmtLabel(top.label)} is uniquely stable under both attacks (Q=${fmt(top.quant)}, R=${fmt(top.relearn)}): internal recoverability is a more reliable signal than output-level metrics.`;
    }
    summaryEl.innerHTML = msg;
  } else {
    summaryEl.innerHTML = "<strong>Meta-evaluation summary:</strong> Overall values are not available yet.";
  }
}

// Load method-level data
async function loadMethodData() {
  try {
    const resp = await fetch('data/method_results.json');
    methodData = await resp.json();
    renderMethodFilters();
    updateEpochCounts();
    renderMethodTable();
    setupMethodListeners();
    setupTableSorting();
  } catch (e) {
    document.getElementById('method_body').innerHTML = '<tr><td colspan="7">Error loading data</td></tr>';
  }
}

function renderMethodFilters() {
  const grid = document.getElementById('method_filters');
  const counts = methodData.method_counts;
  const methods = Object.keys(counts).sort();

  grid.innerHTML = methods.map(m => `
    <label class="checkbox-label">
      <input type="checkbox" class="method-filter" value="${m}" checked>
      ${displayMethod(m)} <span class="count">(${counts[m]})</span>
    </label>
  `).join('');
}

function updateEpochCounts() {
  // Count models per epoch (excluding reference models)
  const epochCounts = {};
  methodData.models.forEach(m => {
    if (!m.is_reference && m.epoch) {
      epochCounts[m.epoch] = (epochCounts[m.epoch] || 0) + 1;
    }
  });
  // Update epoch filter labels
  document.querySelectorAll('.epoch-filter').forEach(cb => {
    const ep = cb.value;
    const count = epochCounts[ep] || 0;
    const label = cb.parentElement;
    const epNum = ep.replace('ep', '');
    label.innerHTML = `<input type="checkbox" class="epoch-filter" value="${ep}" checked> ${epNum} <span class="count">(${count})</span>`;
  });
}

function getFilteredModels() {
  const view = document.getElementById('viewMode').value;
  const rankBy = document.getElementById('rankMetric').value;
  const epochs = new Set([...document.querySelectorAll('.epoch-filter:checked')].map(e => e.value));
  const methods = new Set([...document.querySelectorAll('.method-filter:checked')].map(e => e.value));

  // Filter models
  let models = methodData.models.filter(m => {
    if (m.is_reference) return true;
    return epochs.has(m.epoch) && methods.has(m.method);
  });

  // If top-1 per method view
  if (view === 'best') {
    const refs = models.filter(m => m.is_reference);
    const nonRefs = models.filter(m => !m.is_reference);
    const bestByMethod = {};
    nonRefs.forEach(m => {
      const key = m.method;
      const val = m[rankBy];
      if (val === null || isNaN(val)) return;
      if (!bestByMethod[key] || val > bestByMethod[key][rankBy]) {
        bestByMethod[key] = m;
      }
    });
    models = [...refs, ...Object.values(bestByMethod)];
  }

  return models;
}

function sortModels(models) {
  const methodOrder = ['graddiff', 'idknll', 'idkdpo', 'npo', 'altpo', 'undial', 'simnpo', 'rmu'];

  // If custom sort is active, use it
  if (currentSort.col) {
    return models.slice().sort((a, b) => {
      // Reference rows always stay at top
      if (a.is_reference && !b.is_reference) return -1;
      if (!a.is_reference && b.is_reference) return 1;
      if (a.is_reference && b.is_reference) {
        return a.model === 'full' ? -1 : 1;
      }

      const col = currentSort.col;
      let av = col === 'model' ? a.model : a[col];
      let bv = col === 'model' ? b.model : b[col];

      if (col === 'model') {
        return currentSort.asc ? av.localeCompare(bv) : bv.localeCompare(av);
      }

      // Handle null/NaN
      if (av === null || isNaN(av)) av = -Infinity;
      if (bv === null || isNaN(bv)) bv = -Infinity;

      return currentSort.asc ? av - bv : bv - av;
    });
  }

  // Default sort
  return models.slice().sort((a, b) => {
    if (a.model === 'full') return -1;
    if (b.model === 'full') return 1;
    if (a.model === 'retain') return -1;
    if (b.model === 'retain') return 1;
    const ma = methodOrder.indexOf(a.method), mb = methodOrder.indexOf(b.method);
    if (ma !== mb) return (ma === -1 ? 999 : ma) - (mb === -1 ? 999 : mb);
    if (a.epoch !== b.epoch) return a.epoch.localeCompare(b.epoch);
    return a.model.localeCompare(b.model);
  });
}

function renderMethodTable() {
  const body = document.getElementById('method_body');
  const view = document.getElementById('viewMode').value;

  let models = getFilteredModels();
  models = sortModels(models);

  let html = '';
  models.forEach((m, idx) => {
    const rowClass = m.is_reference ? 'main-row ref-row' : 'main-row';
    const rid = `row_${idx}`;

    html += `<tr class="${rowClass}" data-rid="${rid}">
      <td>${m.model}</td>
      <td class="num">${fmt(m.overall)}</td>
      <td class="num">${fmt(m.mem)}</td>
      <td class="num">${fmt(m.privacy)}</td>
      <td class="num">${fmt(m.utility_rel)}</td>
      <td class="num" style="color:#888;">${fmt(m.uds)}</td>
      <td class="expand-cell"><button class="toggle-btn" data-target="${rid}">▼</button></td>
    </tr>`;

    // Details row - show all content directly
    html += `<tr id="${rid}" class="details-row">
      <td colspan="7">
        <div class="details-grid">
          <div class="detail-card">
            <h4>Memorization</h4>
            <div class="detail-item"><span class="label">1-ES</span><span class="value">${fmt(m.one_minus_es)}</span></div>
            <div class="detail-item"><span class="label">1-EM</span><span class="value">${fmt(m.one_minus_em)}</span></div>
            <div class="detail-item"><span class="label">1-ParaProb</span><span class="value">${fmt(m.one_minus_paraprob)}</span></div>
            <div class="detail-item"><span class="label">1-TruthRatio</span><span class="value">${fmt(m.one_minus_truth)}</span></div>
            <div class="detail-item summary">
              <span class="label"><strong>Mem.</strong></span><span class="value"><strong>${fmt(m.mem)}</strong></span>
            </div>
          </div>
          <div class="detail-card">
            <h4>Privacy</h4>
            <div class="detail-item"><span class="label">s<sub>LOSS</sub></span><span class="value">${fmt(m.s_loss)}</span></div>
            <div class="detail-item"><span class="label">s<sub>ZLib</sub></span><span class="value">${fmt(m.s_zlib)}</span></div>
            <div class="detail-item"><span class="label">s<sub>Min-K</sub></span><span class="value">${fmt(m.s_mink)}</span></div>
            <div class="detail-item"><span class="label">s<sub>Min-K++</sub></span><span class="value">${fmt(m.s_minkpp)}</span></div>
            <div class="detail-item summary">
              <span class="label">MIA</span><span class="value">${fmt(m.privacy_mia)}</span>
            </div>
            <div class="detail-item"><span class="label">UDS</span><span class="value">${fmt(m.uds)}</span></div>
            <div class="detail-item summary">
              <span class="label"><strong>Privacy = HM(MIA, UDS)</strong></span><span class="value"><strong>${fmt(m.privacy)}</strong></span>
            </div>
          </div>
          <div class="detail-card">
            <h4>Utility</h4>
            <div class="detail-item"><span class="label">ModelUtility (MU)</span><span class="value">${fmt(m.model_utility)}</span></div>
            <div class="detail-item"><span class="label">Fluency</span><span class="value">${fmt(m.fluency)}</span></div>
            <div class="detail-item"><span class="label">Utility = HM(MU, Fluency)</span><span class="value">${fmt(m.utility)}</span></div>
            <div class="detail-sub">
              <div><strong>MU components:</strong></div>
              <div>retain: Prob=${fmt(m.retain_q_prob)}, ROUGE=${fmt(m.retain_q_rouge)}, TruthRatio=${fmt(m.retain_truth_ratio)}</div>
              <div>ra: Prob=${fmt(m.ra_q_prob)}, ROUGE=${fmt(m.ra_q_rouge)}, TruthRatio=${fmt(m.ra_truth_ratio)}</div>
              <div>wf: Prob=${fmt(m.wf_q_prob)}, ROUGE=${fmt(m.wf_q_rouge)}, TruthRatio=${fmt(m.wf_truth_ratio)}</div>
            </div>
            <div class="detail-item summary">
              <span class="label"><strong>Utility<sub>rel</sub></strong></span><span class="value"><strong>${fmt(m.utility_rel)}</strong></span>
            </div>
          </div>
        </div>
      </td>
    </tr>`;
  });

  body.innerHTML = html;

  // Update count
  const nonRefCount = models.filter(m => !m.is_reference).length;
  const totalLoaded = methodData.models.length;
  document.getElementById('model_count').textContent =
    `Showing: ${nonRefCount} models` + (view === 'best' ? ' (top-1 per method)' : '') + ` + full + retain (loaded total: ${totalLoaded})`;

  // Update total count in description
  document.getElementById('model_total_count').textContent = totalLoaded;

  // Re-attach toggle listeners
  document.querySelectorAll('.toggle-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      const target = document.getElementById(btn.dataset.target);
      const isHidden = target.style.display !== 'table-row';
      target.style.display = isHidden ? 'table-row' : 'none';
      btn.textContent = isHidden ? '▲' : '▼';
    });
  });
}

function setupTableSorting() {
  document.querySelectorAll('#method_table th.sortable').forEach(th => {
    th.addEventListener('click', () => {
      const col = th.dataset.col;

      // Toggle sort direction
      if (currentSort.col === col) {
        currentSort.asc = !currentSort.asc;
      } else {
        currentSort.col = col;
        currentSort.asc = false; // Default descending for numeric (higher is better)
        if (col === 'model') currentSort.asc = true; // Ascending for model name
      }

      // Update header styles
      document.querySelectorAll('#method_table th.sortable').forEach(h => {
        h.classList.remove('sort-asc', 'sort-desc');
      });
      th.classList.add(currentSort.asc ? 'sort-asc' : 'sort-desc');

      renderMethodTable();
    });
  });
}

function setupMethodListeners() {
  document.getElementById('viewMode').addEventListener('change', () => {
    currentSort = { col: null, asc: true }; // Reset sort on view change
    document.querySelectorAll('#method_table th.sortable').forEach(h => {
      h.classList.remove('sort-asc', 'sort-desc');
    });
    // Show/hide rankMetric based on view mode
    const viewMode = document.getElementById('viewMode').value;
    document.getElementById('rankMetric').style.display = viewMode === 'best' ? 'inline-block' : 'none';
    renderMethodTable();
  });
  document.getElementById('rankMetric').addEventListener('change', renderMethodTable);
  document.querySelectorAll('.epoch-filter').forEach(cb => {
    cb.addEventListener('change', renderMethodTable);
  });

  // Method filter delegation
  document.getElementById('method_filters').addEventListener('change', renderMethodTable);

  document.getElementById('checkAll').addEventListener('click', () => {
    document.querySelectorAll('.method-filter').forEach(cb => cb.checked = true);
    renderMethodTable();
  });

  document.getElementById('uncheckAll').addEventListener('click', () => {
    document.querySelectorAll('.method-filter').forEach(cb => cb.checked = false);
    renderMethodTable();
  });
}

// Initialize
document.addEventListener('DOMContentLoaded', () => {
  loadMetaEval();
  loadMethodData();
});
</script>
</body>
</html>
